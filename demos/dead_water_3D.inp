ocellaris:
    type: input
    version: 1.0

metadata:
    author: Tormod Landet
    date: 2017-12-13
    description: |
        Flow around a parabolic hull in a stratified fluid  

user_code:
    constants:
        # Geometry. DO NOT CHANGE WITHOUT UPDATING gmesh geo FILE!!
        L: 200       # domain length
        H: 30        # domain depth
        B: 30        # domain breadth
        h: 6         # depth to pycnocline
        d: 5         # draught amidships
        l: 30        # length of hull water line
        C: 50        # distance from midships to inlet
        
        # Non-geometry parameters (these are controlled by a post_timestep hook below)
        Velocity: 0.0    # vessel speed (divide by 0.514444 to get knots)
        Tmax:  1.0e+6    # maximum duration
        FRESH: 1000.0    # Upper layer density
        SALT: 1028.0     # Lower layer density
    code: |
        # Run gmsh if the mesh xml file is missing. Requires gmsh version > 3
        # with support for the OpenCASCADE geometry engine
        import os, subprocess, dolfin
        if dolfin.MPI.comm_world.rank == 0 and not simulation.restarted:
            mydir = os.path.dirname(os.path.abspath(__file__))
            geo = os.path.join(mydir, 'datafiles', 'dead_water_3D.geo')
            msh = os.path.join(mydir, 'datafiles', 'dead_water_3D.msh')
            xml = os.path.join(mydir, 'datafiles', 'dead_water_3D.xml')
            assert os.path.isfile(geo)
            if not os.path.isfile(msh):
                print('Running gmsh on', geo)
                subprocess.call(['gmsh', '-2', '-optimize', geo, '-o', msh])
            if not os.path.isfile(xml):
                print('Running meshio-convert on', msh)
                subprocess.call(['meshio-convert', '--input-format', 'gmsh-ascii',
                                 '--output-format', 'dolfin-xml', msh, xml])
        dolfin.MPI.comm_world.barrier()

_physical_properties:
    g: [0, 0, -9.81]
    nu0: 1.0e-6
    rho0: py$ SALT
    nu1: 1.0e-6
    rho1: py$ FRESH

physical_properties:
    nu: 1.0e-6
    rho_min: py$ FRESH
    rho_max: py$ SALT
    g: [0, 0, -9.81]

mesh:
    type: XML
    mesh_file: datafiles/dead_water_3D.xml
    
    #type: HDF5
    #mesh_file: output/dead_water_3D_rstairs01_savepoint_U_2.000.h5

boundary_conditions:

-   name: Hull
    selector: code
    inside_code: 'on_boundary'
    u:
        type: FreeSlip

-   name: Inlet
    selector: code
    inside_code: 'on_boundary and x[0] < 1e-5'
    u:
        type: CppCodedValue
        cpp_code: ['Velocity', '0', '0']
    #c:
    #    type: CppCodedValue
    #    cpp_code: '(x[1] < -h + 1e-5) ? 1.0 : 0.0'
    rho:
        type: CppCodedValue
        cpp_code: '(x[2] < -h + 1e-5) ? SALT : FRESH'

-   name: Outlet
    selector: code
    inside_code: 'on_boundary and x[0] > C + l'
    u:
        type: CppCodedValue
        cpp_code: ['Velocity', '0', '0']
    #u0: {type: 'ConstantGradient', value: 0}
    #u1: {type: 'ConstantValue', value: 0}
    #u2: {type: 'ConstantValue', value: 0}
    #c:
    #    type: CppCodedValue
    #    cpp_code: '(x[1] < -h + 1e-5) ? 1.0 : 0.0'
    rho:
        type: CppCodedValue
        cpp_code: '(x[2] < -h + 1e-5) ? SALT : FRESH'

-   name: Bottom
    selector: code
    inside_code: 'on_boundary and x[2] < -H + 1e-5'
    u:
        type: CppCodedValue
        cpp_code: ['Velocity', '0', '0']

-   name: Surface z=0
    selector: code
    inside_code: 'on_boundary and x[2] > -1e-5'
    u:
        type: FreeSlip

-   name: Sides
    selector: code
    inside_code: 'on_boundary and (x[1] > B/2 - 1e-5 or x[1] < 1e-5)'
    u:
        type: FreeSlip

_initial_conditions:
    file:
        h5_file: output/dead_water_3D_rstairs01_savepoint_U_2.000.h5
        same_mesh: yes

time:
    dt: 0.1
    tmax: py$ Tmax

output:
    prefix: output/dead_water_3D_stairs_finer_08
    dolfin_log_level: warning
    ocellaris_log_level: info
    xdmf_write_interval: 200
    hdf5_write_interval: 200

solver:
    type: IPCS-A
    num_inner_iter: py$ 30 if it < 3 else (10 if it < 10 else 3)
    allowable_error_inner: 1.0e-4
    polynomial_degree_pressure: 1
    polynomial_degree_velocity: 2
    function_space_pressure: DG
    function_space_velocity: DG
    #steady_velocity_stopping_criterion: 1e-5
    #force_steady: no

_multiphase_solver:
    type: BlendedAlgebraicVOF

multiphase_solver:
    type: VariableDensity
    function_space_rho: DG
    polynomial_degree_rho: 2

slope_limiter:
    rho:
        method: HierarchicalTaylor
        skip_boundary: no
        enforce_bounds: yes
        enforce_bcs: no

probes:
    -   name: free_surface
        enabled: no
        type: IsoSurface
        value: py$ (SALT + FRESH) / 2
        field: rho
        file_name: '_free_surface.out'
        write_interval: 10
        custom_hook: MultiPhaseModelUpdated

hooks:
    pre_simulation:

    -   name: Initial density field with discrete jump at z=-h
        enabled: yes
        code: |
            if t < 1:
                # We assume that the mesh aligns with the pycnocline
                dm = Vrho.dofmap()
                arr = rho.vector().get_local()
                for cell in cells(mesh):
                    rho_cell = SALT if cell.midpoint().z() < -h else FRESH
                    for dof in dm.cell_dofs(cell.index()):
                        arr[dof] = rho_cell
                rho.vector().set_local(arr)
                rho.vector().apply('insert')
                rho_p.assign(rho)
                rho_pp.assign(rho)

    post_timestep:

    -   name: Forces on the hull
        enabled: yes
        code: |
            if not hook_data:
                hull_id = boundary_by_name['Hull'].mark_id
                hull_ds = ds(hull_id)
                n = FacetNormal(mesh)
                Fpx = Form(p * dot(n, as_vector([1, 0, 0])) * hull_ds)
                Fpy = Form(p * dot(n, as_vector([0, 1, 0])) * hull_ds)
                Fpz = Form(p * dot(n, as_vector([0, 0, 1])) * hull_ds)
                hook_data['forceforms'] = (Fpx, Fpy, Fpz)
            Fpx, Fpy, Fpz = hook_data['forceforms']
            simulation.reporting.report_timestep_value('Fpx', assemble(Fpx))
            simulation.reporting.report_timestep_value('Fpy', assemble(Fpy))
            simulation.reporting.report_timestep_value('Fpz', assemble(Fpz))

            N = 300
            all_Fpx = simulation.reporting.timestep_xy_reports['Fpx']
            simulation.reporting.report_timestep_value('Fpx_avg', numpy.mean(all_Fpx[-N:]))
            simulation.reporting.report_timestep_value('Fpx_std', numpy.std(all_Fpx[-N:]))

    -   name: Update velocity
        enabled: yes
        code: |
            U_vals = [0.00, 0.25, 0.50, 0.75, 1.00, 1.25, 1.50, 1.75, 2.0, 2.25]
            U_vals = [0.00, 1.00, 1.25, 1.50, 1.75, 2.0]
            Nramp = 200
            Ntot = 2800
            prefix = simulation.input.get_value('output/prefix', '')
            
            if not hook_data:
                simulation.log.warning('Creating initial update velocity hook data')
                hook_data['iU'] = 0
                hook_data['t_start'] = -1
                hook_data['t_ramp'] = -1
                hook_data['t_end'] = -1
            
            i = hook_data['iU']
            U = U_vals[i]
            
            t1, t2, t3 = hook_data['t_start'], hook_data['t_ramp'], hook_data['t_end']
            if t > t3:
                if simulation.timestep_restart > 5:
                    fn = prefix + '_savepoint_U_%.3f.h5' % U
                    simulation.io.write_restart_file(fn)
                    simulation.log.info('Saving restart file at end of velocity %.2f' % U)
                
                if i == len(U_vals) - 1:
                    simulation.log.info('End of velocity vector, stopping')
                    simulation.input.set_value('time/tmax', t)
                else:
                    # Go to next velocity
                    hook_data['iU'] += 1
                    dt = 0.1 / U_vals[hook_data['iU']]
                    simulation.input.set_value('time/dt', dt)
                    simulation.data['time_coeffs'].assign(dolfin.Constant([1, -1, 0]))
                    simulation.log.info('Changing timestep to %r' % dt)
                    hook_data['Uprev'] = U
                    hook_data['t_start'] = t
                    hook_data['t_ramp'] = t + dt * Nramp
                    hook_data['t_end'] = t + dt * Ntot
            elif t < t2:
                f = (t - t1) / (t2 - t1)
                F = (3 * f**2 - 2 * f**3)
                U = (1 - F) * hook_data['Uprev'] +  F * U
            
            Vel = simulation.input.get_value('user_code/constants/Velocity')
            simulation.reporting.report_timestep_value('Vel', Vel)
            simulation.input.set_value('user_code/constants/Velocity', U)

            #if simulation.timestep % 100:
            #    fn = prefix + '_restart.h5'
            #    simulation.io.write_restart_file(fn)
            #    simulation.log.info('Saving restart file at timestep %d' % simulation.timestep)
